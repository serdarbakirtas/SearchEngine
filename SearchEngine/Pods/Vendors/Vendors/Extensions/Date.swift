//
//  Date.swift
//  TinySwift
//
//  Created by Piotr Sochalewski on 27.09.2016.
//  Copyright © 2016 Piotr Sochalewski. All rights reserved.
//

import Foundation

// DotNet: "/Date(1268123281843)/"
public let DefaultFormat = "EEE MMM dd HH:mm:ss Z yyyy"
public let RSSFormat = "EEE, d MMM yyyy HH:mm:ss ZZZ" // "Fri, 09 Sep 2011 15:26:08 +0200"
public let AltRSSFormat = "d MMM yyyy HH:mm:ss ZZZ" // "09 Sep 2011 15:26:08 +0200"
public enum ISO8601Format: String {

    case year = "yyyy" // 1997
    case yearMonth = "yyyy-MM" // 1997-07
    case date = "yyyy-MM-dd" // 1997-07-16
    case dateTime = "yyyy-MM-dd'T'HH:mmZ" // 1997-07-16T19:20+01:00
    case dateTimeSec = "yyyy-MM-dd'T'HH:mm:ssZ" // 1997-07-16T19:20:30+01:00
    case dateTimeMilliSec = "yyyy-MM-dd'T'HH:mm:ss.SSSZ" // 1997-07-16T19:20:30.45+01:00

    init(dateString: String) {
        switch dateString.length {
        case 4:
            self = ISO8601Format(rawValue: ISO8601Format.year.rawValue)!
        case 7:
            self = ISO8601Format(rawValue: ISO8601Format.yearMonth.rawValue)!
        case 10:
            self = ISO8601Format(rawValue: ISO8601Format.date.rawValue)!
        case 22:
            self = ISO8601Format(rawValue: ISO8601Format.dateTime.rawValue)!
        case 25:
            self = ISO8601Format(rawValue: ISO8601Format.dateTimeSec.rawValue)!
        default: // 28:
            self = ISO8601Format(rawValue: ISO8601Format.dateTimeMilliSec.rawValue)!
        }
    }
}

public enum DateFormat {
    case iso8601(ISO8601Format?), dotNet, rss, altRSS, custom(String)
}

public var minuteInSeconds: Double = 60
public var hourInSeconds: Double = 3600
public var dayInSeconds: Double = 86400
public var weekInSeconds: Double = 604800
public var yearInSeconds: Double = 31556926

public enum TimeZoneSimple {
    case local, utc
}

public extension Date {

    var timeAgo:String {
        return (self as NSDate).timeAgo()
    }
    
    // MARK: Static Cached Formatters

    /**
     Returns a cached static array of NSDateFormatters so that thy are only created once.
     */
    private static func sharedDateFormatters() -> [String: DateFormatter] {
        struct Static {
            static var formatters: [String: DateFormatter]? = [String: DateFormatter]()
        }
        return Static.formatters!
    }

    /**
     Returns a cached formatter based on the format, timeZone and locale. Formatters are cached in a singleton array using hashkeys generated by format, timeZone and locale.

     - Parameter format: The format to use.
     - Parameter timeZone: The time zone to use, defaults to the local time zone.
     - Parameter locale: The locale to use, defaults to the current locale
     - Returns The date formatter.
     */
    private static func formatter(_ format: String = DefaultFormat, timeZone: Foundation.TimeZone = Foundation.TimeZone.current, locale: Locale = Locale.current) -> DateFormatter {
        let hashKey = "\(format.hashValue)\(timeZone.hashValue)\(locale.hashValue)"
        var formatters = Date.sharedDateFormatters()
        if let cachedDateFormatter = formatters[hashKey] {
            return cachedDateFormatter
        } else {
            let formatter = DateFormatter()
            formatter.dateFormat = format
            formatter.timeZone = timeZone
            formatter.locale = locale
            formatters[hashKey] = formatter
            return formatter
        }
    }

    /**
     Returns a cached formatter based on date style, time style and relative date. Formatters are cached in a singleton array using hashkeys generated by date style, time style, relative date, timeZone and locale.

     - Parameter dateStyle: The date style to use.
     - Parameter timeStyle: The time style to use.
     - Parameter doesRelativeDateFormatting: Enables relative date formatting.
     - Parameter timeZone: The time zone to use.
     - Parameter locale: The locale to use.
     - Returns The date formatter.
     */
    private static func formatter(_ dateStyle: DateFormatter.Style, timeStyle: DateFormatter.Style, doesRelativeDateFormatting: Bool, timeZone: Foundation.TimeZone = Foundation.NSTimeZone.local, locale: Locale = Locale.current) -> DateFormatter {
        var formatters = Date.sharedDateFormatters()
        let hashKey = "\(dateStyle.hashValue)\(timeStyle.hashValue)\(doesRelativeDateFormatting.hashValue)\(timeZone.hashValue)\(locale.hashValue)"
        if let cachedDateFormatter = formatters[hashKey] {
            return cachedDateFormatter
        } else {
            let formatter = DateFormatter()
            formatter.dateStyle = dateStyle
            formatter.timeStyle = timeStyle
            formatter.doesRelativeDateFormatting = doesRelativeDateFormatting
            formatter.timeZone = timeZone
            formatter.locale = locale
            formatters[hashKey] = formatter
            return formatter
        }
    }

    public init(fromString string: String, format: DateFormat, timeZone: TimeZoneSimple = .local) {
        if string.isEmpty {
            self.init()
            return
        }

        let string = string as NSString

        let zone: Foundation.TimeZone

        switch timeZone {
        case .local:
            zone = Foundation.NSTimeZone.local
        case .utc:
            zone = Foundation.TimeZone(secondsFromGMT: 0)!
        }

        switch format {

        case .dotNet:

            let startIndex = string.range(of: "(").location + 1
            let endIndex = string.range(of: ")").location
            let range = NSRange(location: startIndex, length: endIndex - startIndex)
            let milliseconds = (string.substring(with: range) as NSString).longLongValue
            let interval = TimeInterval(milliseconds / 1000)
            self.init(timeIntervalSince1970: interval)

        case let .iso8601(isoFormat):

            let dateFormat = (isoFormat != nil) ? isoFormat! : ISO8601Format(dateString: string as String)
            let formatter = Date.formatter(dateFormat.rawValue)
            formatter.locale = Foundation.Locale(identifier: "en_US_POSIX")
            formatter.timeZone = Foundation.NSTimeZone.local
            formatter.dateFormat = dateFormat.rawValue
            if let date = formatter.date(from: string as String) {
                self.init(timeInterval: 0, since: date)
            } else {
                self.init()
            }

        case .rss:

            var s = string
            if string.hasSuffix("Z") {
                s = s.substring(to: s.length - 1).appending("GMT") as NSString
            }
            let formatter = Date.formatter(RSSFormat)
            if let date = formatter.date(from: string as String) {
                self.init(timeInterval: 0, since: date)
            } else {
                self.init()
            }

        case .altRSS:

            var s = string
            if string.hasSuffix("Z") {
                s = s.substring(to: s.length - 1).appending("GMT") as NSString
            }
            let formatter = Date.formatter(AltRSSFormat)
            if let date = formatter.date(from: string as String) {
                self.init(timeInterval: 0, since: date)
            } else {
                self.init()
            }

        case let .custom(dateFormat):

            let formatter = Date.formatter(dateFormat, timeZone: zone)
            if let date = formatter.date(from: string as String) {
                self.init(timeInterval: 0, since: date)
            } else {
                self.init()
            }
        }
    }

    // Create a new date form calendar components.
    ///
    /// - Parameters:
    ///   - calendar: Calendar (default is current).
    ///   - timeZone: TimeZone (default is current).
    ///   - era: Era (default is current era).
    ///   - year: Year (default is current year).
    ///   - month: Month (default is current month).
    ///   - day: Day (default is today).
    ///   - hour: Hour (default is current hour).
    ///   - minute: Minute (default is current minute).
    ///   - second: Second (default is current second).
    ///   - nanosecond: Nanosecond (default is current nanosecond).
    public init?(
        calendar: Calendar? = Calendar.current,
        timeZone: TimeZone? = TimeZone.current,
        era: Int? = Date().era,
        year: Int? = Date().year,
        month: Int? = Date().month,
        day: Int? = Date().day,
        hour: Int? = Date().hour,
        minute: Int? = Date().minute,
        second: Int? = Date().second,
        nanosecond: Int? = Date().nanosecond
    ) {

        var components = DateComponents()
        components.calendar = calendar
        components.timeZone = timeZone
        components.era = era
        components.year = year
        components.month = month
        components.day = day
        components.hour = hour
        components.minute = minute
        components.second = second
        components.nanosecond = nanosecond

        if let date = calendar?.date(from: components) {
            self = date
        } else {
            return nil
        }
    }

    // Create new date object from UNIX timestamp.
    ///
    /// - Parameter unixTimestamp: UNIX timestamp.
    public init(unixTimestamp: Double) {
        self.init(timeIntervalSince1970: unixTimestamp)
    }

    /// Returns a new Date by setting this Date's day to first.
    public var firstOfMonth: Date? {
        let calendar = Calendar.current
        let components = calendar.dateComponents([.year, .month], from: self)

        return calendar.date(from: components)
    }

    /// Returns a new Date by setting this Date's day to last.
    public var lastOfMonth: Date? {
        guard let firstOfMonth = firstOfMonth else { return nil }

        var components = DateComponents()
        components.month = 1
        components.day = -1

        return Calendar.current.date(byAdding: components, to: firstOfMonth)
    }

    /// Returns a new Date by setting this Date's day and month to first.
    public var firstOfYear: Date? {
        let calendar = Calendar.current
        let components = calendar.dateComponents([.year], from: self)

        return calendar.date(from: components)
    }

    /// Returns a new Date by setting this Date's day and month to last.
    public var lastOfYear: Date? {
        guard let firstOfYear = firstOfYear else { return nil }

        var components = DateComponents()
        components.year = 1
        components.day = -1

        return Calendar.current.date(byAdding: components, to: firstOfYear)
    }

    /// Returns a new Date with the day following this Date.
    public var nextDay: Date? {
        var components = DateComponents()
        components.day = 1

        return Calendar.current.date(byAdding: components, to: self)
    }

    /// Returns a new Date with the day preceding this Date.
    public var previousDay: Date? {
        var components = DateComponents()
        components.day = -1

        return Calendar.current.date(byAdding: components, to: self)
    }

    private static func componentFlags() -> Set<Calendar.Component> { return [Calendar.Component.year, Calendar.Component.month, Calendar.Component.day, Calendar.Component.weekOfYear, Calendar.Component.hour, Calendar.Component.minute, Calendar.Component.second, Calendar.Component.weekday, Calendar.Component.weekdayOrdinal, Calendar.Component.weekOfYear] }

    private static func components(_ fromDate: Date) -> DateComponents! {
        return Calendar.current.dateComponents(Date.componentFlags(), from: fromDate)
    }

    private func components() -> DateComponents {
        return Date.components(self)!
    }

    func isEqualToDateIgnoringTime(_ date: Date) -> Bool {
        let comp1 = Date.components(self)
        let comp2 = Date.components(date)
        return ((comp1!.year == comp2!.year) && (comp1!.month == comp2!.month) && (comp1!.day == comp2!.day))
    }

    /**
     Creates a new date by a adding days.

     - Parameter days: The number of days to add.
     - Returns A new date object.
     */
    func dateByAddingDays(_ days: Int) -> Date {
        var dateComp = DateComponents()
        dateComp.day = days
        return Calendar.current.date(byAdding: dateComp, to: self)!
    }

    /**
     Creates a new date by a substracting days.

     - Parameter days: The number of days to substract.
     - Returns A new date object.
     */
    func dateBySubtractingDays(_ days: Int) -> Date {
        var dateComp = DateComponents()
        dateComp.day = (days * -1)
        return Calendar.current.date(byAdding: dateComp, to: self)!
    }

    /**
     Creates a new date by a adding hours.

     - Parameter days: The number of hours to add.
     - Returns A new date object.
     */
    func dateByAddingHours(_ hours: Int) -> Date {
        var dateComp = DateComponents()
        dateComp.hour = hours
        return Calendar.current.date(byAdding: dateComp, to: self)!
    }

    /**
     Creates a new date by substracting hours.

     - Parameter days: The number of hours to substract.
     - Returns A new date object.
     */
    func dateBySubtractingHours(_ hours: Int) -> Date {
        var dateComp = DateComponents()
        dateComp.hour = (hours * -1)
        return Calendar.current.date(byAdding: dateComp, to: self)!
    }

    /**
     Creates a new date by adding minutes.

     - Parameter days: The number of minutes to add.
     - Returns A new date object.
     */
    func dateByAddingMinutes(_ minutes: Int) -> Date {
        var dateComp = DateComponents()
        dateComp.minute = minutes
        return Calendar.current.date(byAdding: dateComp, to: self)!
    }

    /**
     Creates a new date by substracting minutes.

     - Parameter days: The number of minutes to add.
     - Returns A new date object.
     */
    func dateBySubtractingMinutes(_ minutes: Int) -> Date {
        var dateComp = DateComponents()
        dateComp.minute = (minutes * -1)
        return Calendar.current.date(byAdding: dateComp, to: self)!
    }

    /**
     Creates a new date by adding seconds.

     - Parameter seconds: The number of seconds to add.
     - Returns A new date object.
     */
    func dateByAddingSeconds(_ seconds: Int) -> Date {
        var dateComp = DateComponents()
        dateComp.second = seconds
        return Calendar.current.date(byAdding: dateComp, to: self)!
    }

    /**
     Creates a new date by substracting seconds.

     - Parameter days: The number of seconds to substract.
     - Returns A new date object.
     */
    func dateBySubtractingSeconds(_ seconds: Int) -> Date {
        var dateComp = DateComponents()
        dateComp.second = (seconds * -1)
        return Calendar.current.date(byAdding: dateComp, to: self)!
    }

    var isToday: Bool {
        return self.isEqualToDateIgnoringTime(Date())
    }

    /**
     Returns true if date is tomorrow.
     */
    func isTomorrow() -> Bool {
        return isEqualToDateIgnoringTime(Date().dateByAddingDays(1))
    }

    /**
     Returns true if date is yesterday.
     */
    func isYesterday() -> Bool {
        return isEqualToDateIgnoringTime(Date().dateBySubtractingDays(1))
    }

    /**
     Returns true if date are in the same week.

     - Parameter date: The date to compare.
     */
    func isSameWeekAsDate(_ date: Date) -> Bool {
        let comp1 = Date.components(self)
        let comp2 = Date.components(date)
        // Must be same week. 12/31 and 1/1 will both be week "1" if they are in the same week
        if comp1?.weekOfYear != comp2?.weekOfYear {
            return false
        }
        // Must have a time interval under 1 week
        return abs(timeIntervalSince(date)) < weekInSeconds
    }

    /**
     Returns true if date is this week.
     */
    func isThisWeek() -> Bool {
        return isSameWeekAsDate(Date())
    }

    /**
     Returns true if date is next week.
     */
    func isNextWeek() -> Bool {
        let interval: TimeInterval = Date().timeIntervalSinceReferenceDate + weekInSeconds
        let date = Date(timeIntervalSinceReferenceDate: interval)
        return isSameWeekAsDate(date)
    }

    /**
     Returns true if date is last week.
     */
    func isLastWeek() -> Bool {
        let interval: TimeInterval = Date().timeIntervalSinceReferenceDate - weekInSeconds
        let date = Date(timeIntervalSinceReferenceDate: interval)
        return isSameWeekAsDate(date)
    }

    /**
     Returns true if dates are in the same year.

     - Parameter date: The date to compare.
     */
    func isSameYearAsDate(_ date: Date) -> Bool {
        let comp1 = Date.components(self)
        let comp2 = Date.components(date)
        return comp1!.year == comp2!.year
    }

    /**
     Returns true if dates are in the same month

     - Parameter date: The date to compare
     */
    func isSameMonthAsDate(_ date: Date) -> Bool {
        let comp1 = Date.components(self)
        let comp2 = Date.components(date)

        return comp1!.year == comp2!.year && comp1!.month == comp2!.month
    }

    /**
     Returns true if date is this year.
     */
    func isThisYear() -> Bool {
        return isSameYearAsDate(Date())
    }

    /**
     Returns true if date is next year.
     */
    func isNextYear() -> Bool {
        let comp1 = Date.components(self)
        let comp2 = Date.components(Date())
        return (comp1!.year! == comp2!.year! + 1)
    }

    /**
     Returns true if date is last year.
     */
    func isLastYear() -> Bool {
        let comp1 = Date.components(self)
        let comp2 = Date.components(Date())
        return (comp1!.year! == comp2!.year! - 1)
    }

    /**
     Returns true if date is earlier than date.

     - Parameter date: The date to compare.
     */
    func isEarlierThanDate(_ date: Date) -> Bool {
        return (self as NSDate).earlierDate(date) == self
    }

    /**
     Returns true if date is later than date.

     - Parameter date: The date to compare.
     */
    func isLaterThanDate(_ date: Date) -> Bool {
        return (self as NSDate).laterDate(date) == self
    }

    /**
     Returns true if date is in future.
     */
    func isInFuture() -> Bool {
        return isLaterThanDate(Date())
    }

    /**
     Returns true if date is in past.
     */
    func isInPast() -> Bool {
        return isEarlierThanDate(Date())
    }

    // User’s current calendar.
    public var calendar: Calendar {
        return Calendar.current
    }

    // Time zone used by system.
    public var timeZone: TimeZone {
        return self.calendar.timeZone
    }

    // UNIX timestamp from date.
    public var unixTimestamp: Double {
        return timeIntervalSince1970
    }

    // Era.
    public var era: Int {
        return calendar.component(.era, from: self)
    }

    // Year.
    public var year: Int {
        get {
            return calendar.component(.year, from: self)
        }
        set {
            self = Date(calendar: self.calendar, timeZone: self.timeZone, era: self.era, year: newValue, month: self.month, day: self.day, hour: self.hour, minute: self.minute, second: self.second, nanosecond: self.nanosecond) ?? self
        }
    }

    // Week of year.
    public var weekOfYear: Int {
        return calendar.component(.weekOfYear, from: self)
    }

    // Week of month.
    public var weekOfMonth: Int {
        return calendar.component(.weekOfMonth, from: self)
    }

    // Weekday.
    public var weekday: Int {
        return calendar.component(.weekday, from: self)
    }

    // Day.
    public var day: Int {
        get {
            return calendar.component(.day, from: self)
        }
        set {
            self = Date(calendar: calendar, timeZone: timeZone, era: era, year: year, month: month, day: newValue, hour: hour, minute: minute, second: second, nanosecond: nanosecond) ?? self
        }
    }

    // Hour.
    public var hour: Int {
        get {
            return calendar.component(.hour, from: self)
        }
        set {
            self = Date(calendar: calendar, timeZone: timeZone, era: era, year: year, month: month, day: day, hour: newValue, minute: minute, second: second, nanosecond: nanosecond) ?? self
        }
    }

    // Minutes.
    public var minute: Int {
        get {
            return calendar.component(.minute, from: self)
        }
        set {
            self = Date(calendar: calendar, timeZone: timeZone, era: era, year: year, month: month, day: day, hour: hour, minute: newValue, second: second, nanosecond: nanosecond) ?? self
        }
    }

    // Seconds.
    public var second: Int {
        get {
            return calendar.component(.second, from: self)
        }
        set {
            self = Date(calendar: calendar, timeZone: timeZone, era: era, year: year, month: month, day: day, hour: hour, minute: minute, second: newValue, nanosecond: nanosecond) ?? self
        }
    }

    // Nanoseconds.
    public var nanosecond: Int {
        return calendar.component(.nanosecond, from: self)
    }

    // Month.
    public var month: Int {
        get {
            return calendar.component(.month, from: self)
        }
        set {
            self = Date(calendar: calendar, timeZone: timeZone, era: era, year: year, month: newValue, day: day, hour: hour, minute: minute, second: second, nanosecond: nanosecond) ?? self
        }
    }

    public var firstDayOfWeek: Date {
        var beginningOfWeek = Date()
        var interval = TimeInterval()
        
        _ = Calendar.current.dateInterval(of: .weekOfYear, start: &beginningOfWeek, interval: &interval, for: self)
        return beginningOfWeek
    }
    
    public var etaShort: String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.day, .hour, .minute]
        formatter.unitsStyle = .short
        return formatter.string(from: Date(), to: self) ?? "-"
    }

    public var etaFull: String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.day, .hour, .minute]
        formatter.unitsStyle = .short
        return formatter.string(from: Date(), to: self) ?? "-"
    }

    
    /// SwifterSwift: Nearest five minutes to date.
    public var nearestFiveMinutes: Date {
        var components = Calendar.current.dateComponents([.year, .month, .day, .hour, .minute], from: self)
        let min = components.minute!
        components.minute! = min % 5 < 3 ? min - min % 5 : min + 5 - (min % 5)
        components.second = 0
        return Calendar.current.date(from: components)!
    }

    /// SwifterSwift: Nearest ten minutes to date.
    public var nearestTenMinutes: Date {
        var components = Calendar.current.dateComponents([.year, .month, .day, .hour, .minute], from: self)
        let min = components.minute!
        components.minute? = min % 10 < 6 ? min - min % 10 : min + 10 - (min % 10)
        components.second = 0
        return Calendar.current.date(from: components)!
    }

    /// SwifterSwift: Nearest quarter hour to date.
    public var nearestQuarterHour: Date {
        var components = Calendar.current.dateComponents([.year, .month, .day, .hour, .minute], from: self)
        let min = components.minute!
        components.minute! = min % 15 < 8 ? min - min % 15 : min + 15 - (min % 15)
        components.second = 0
        return Calendar.current.date(from: components)!
    }

    /// SwifterSwift: Nearest half hour to date.
    public var nearestHalfHour: Date {
        var components = Calendar.current.dateComponents([.year, .month, .day, .hour, .minute], from: self)
        let min = components.minute!
        components.minute! = min % 30 < 15 ? min - min % 30 : min + 30 - (min % 30)
        components.second = 0
        return Calendar.current.date(from: components)!
    }

    /// SwifterSwift: Nearest hour to date.
    public var nearestHour: Date {
        if minute >= 30 {
            return beginning(of: .hour)!.adding(.hour, value: 1)
        }
        return beginning(of: .hour)!
    }

    // Data at the beginning of calendar component.
    ///
    /// - Parameter component: calendar component to get date at the beginning of.
    /// - Returns: date at the beginning of calendar component (if applicable).
    public func beginning(of component: Calendar.Component) -> Date? {
        switch component {
        case .second:
            return calendar.date(from: calendar.dateComponents([.year, .month, .day, .hour, .minute, .second], from: self))

        case .minute:
            return calendar.date(from: calendar.dateComponents([.year, .month, .day, .hour, .minute], from: self))

        case .hour:
            return calendar.date(from: calendar.dateComponents([.year, .month, .day, .hour], from: self))

        case .day:
            return calendar.startOfDay(for: self)

        case .weekOfYear, .weekOfMonth:
            return calendar.date(from: calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from: self))

        case .month:
            return calendar.date(from: calendar.dateComponents([.year, .month], from: self))

        case .year:
            return calendar.date(from: calendar.dateComponents([.year], from: self))

        default:
            return nil
        }
    }

    // Date by adding multiples of calendar component.
    ///
    /// - Parameters:
    ///   - component: component type.
    ///   - value: multiples of compnenets to add.
    /// - Returns: original date + multiples of compnenet added.
    public func adding(_ component: Calendar.Component, value: Int) -> Date {
        switch component {
        case .second:
            return calendar.date(byAdding: .second, value: value, to: self) ?? self

        case .minute:
            return calendar.date(byAdding: .minute, value: value, to: self) ?? self

        case .hour:
            return calendar.date(byAdding: .hour, value: value, to: self) ?? self

        case .day:
            return calendar.date(byAdding: .day, value: value, to: self) ?? self

        case .weekOfYear, .weekOfMonth:
            return calendar.date(byAdding: .day, value: value * 7, to: self) ?? self

        case .month:
            return calendar.date(byAdding: .month, value: value, to: self) ?? self

        case .year:
            return calendar.date(byAdding: .year, value: value, to: self) ?? self

        default:
            return self
        }
    }

    // Add calendar component to date.
    ///
    /// - Parameters:
    ///   - component: component type.
    ///   - value: multiples of compnenet to add.
    public mutating func add(_ component: Calendar.Component, value: Int) {
        switch component {
        case .second:
            self = calendar.date(byAdding: .second, value: value, to: self) ?? self
            break

        case .minute:
            self = calendar.date(byAdding: .minute, value: value, to: self) ?? self
            break

        case .hour:
            self = calendar.date(byAdding: .hour, value: value, to: self) ?? self
            break

        case .day:
            self = calendar.date(byAdding: .day, value: value, to: self) ?? self
            break

        case .weekOfYear, .weekOfMonth:
            self = calendar.date(byAdding: .day, value: value * 7, to: self) ?? self
            break

        case .month:
            self = calendar.date(byAdding: .month, value: value, to: self) ?? self
            break

        case .year:
            self = calendar.date(byAdding: .year, value: value, to: self) ?? self
            break

        default:
            break
        }
    }

    // Date at the end of calendar component.
    ///
    /// - Parameter component: calendar component to get date at the end of.
    /// - Returns: date at the end of calendar component (if applicable).
    public func end(of component: Calendar.Component) -> Date? {
        switch component {
        case .second:
            var date = adding(.second, value: 1)
            guard let after = calendar.date(from: calendar.dateComponents([.year, .month, .day, .hour, .minute, .second], from: date)) else {
                return nil
            }
            date = after
            date.add(.second, value: -1)
            return date

        case .minute:
            var date = adding(.minute, value: 1)
            guard let after = calendar.date(from: calendar.dateComponents([.year, .month, .day, .hour, .minute], from: date)) else {
                return nil
            }
            date = after.adding(.second, value: -1)
            return date

        case .hour:
            var date = adding(.hour, value: 1)
            guard let after = calendar.date(from: calendar.dateComponents([.year, .month, .day, .hour], from: self)) else {
                return nil
            }
            date = after.adding(.second, value: -1)
            return date

        case .day:
            var date = adding(.day, value: 1)
            date = date.calendar.startOfDay(for: date)
            date.add(.second, value: -1)
            return date

        case .weekOfYear, .weekOfMonth:
            var date = self
            guard let beginningOfWeek = calendar.date(from: calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from: self)) else {
                return nil
            }
            date = beginningOfWeek.adding(.day, value: 7).adding(.second, value: -1)
            return date

        case .month:
            var date = adding(.month, value: 1)
            guard let after = calendar.date(from: calendar.dateComponents([.year, .month], from: self)) else {
                return nil
            }
            date = after.adding(.second, value: -1)
            return date

        case .year:
            var date = adding(.year, value: 1)
            guard let after = calendar.date(from: calendar.dateComponents([.year], from: self)) else {
                return nil
            }
            date = after.adding(.second, value: -1)
            return date

        default:
            return nil
        }
    }

    // Check if date is in current given calendar component.
    ///
    /// - Parameter component: calendar componenet to check.
    /// - Returns: true if date is in current given calendar component.
    public func isInCurrent(_ component: Calendar.Component) -> Bool {
        switch component {
        case .second:
            return second == Date().second && minute == Date().minute && hour == Date().hour && day == Date().day
                && month == Date().month && year == Date().year && era == Date().era

        case .minute:
            return minute == Date().minute && hour == Date().hour && day == Date().day && month == Date().month
                && year == Date().year && era == Date().era

        case .hour:
            return hour == Date().hour && day == Date().day && month == Date().month && year == Date().year
                && era == Date().era

        case .day:
            return day == Date().day && month == Date().month && year == Date().year && era == Date().era

        case .weekOfYear, .weekOfMonth:
            let beginningOfWeek = Date().beginning(of: .weekOfMonth)!
            let endOfWeek = Date().end(of: .weekOfMonth)!
            return self >= beginningOfWeek && self <= endOfWeek

        case .month:
            return month == Date().month && year == Date().year && era == Date().era

        case .year:
            return year == Date().year && era == Date().era

        case .era:
            return era == Date().era

        default:
            return false
        }
    }
    
    var startOfDay: Date {
        return Calendar.current.startOfDay(for: self)
    }

    
    var endOfDay: Date {
        let cal = Calendar.current
        var components = DateComponents()
        components.day = 1
        return cal.date(byAdding: components, to: self.startOfDay)!.addingTimeInterval(-1)
    }
    
    var percentageOfDay: Double {
        let totalSeconds = self.endOfDay.timeIntervalSince(self.startOfDay) + 1
        let seconds = self.timeIntervalSince(self.startOfDay)
        let percentage = seconds / totalSeconds
        return max(min(percentage, 1.0), 0.0)
    }

    var numberOfWeeksInMonth: Int {
        let calendar = Calendar.current
        let weekRange = (calendar as NSCalendar).range(of: NSCalendar.Unit.weekOfYear, in: NSCalendar.Unit.month, for: self)
        
        return weekRange.length
    }
}
